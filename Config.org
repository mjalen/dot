#+PROPERTY: header-args+ :comments both
#+PROPERTY: header-args+ :mkdirp yes
#+PROPERTY: header-args+ :tangle "<filename>"
#+title: Nix Configuration
#+author: Jalen Moore

* Flake

The flake file for the entire configuration.

#+begin_src nix :tangle ./flake.nix
  { 
    description = ''Jalen Moore's Nix configuration.'';

    outputs = { self, ... } @ inputs:
      let
        system = "x86_64-linux";
        pkgs = import inputs.nixpkgs {
          inherit system;
          config.allowUnfree = true;
          overlays = [ 
            inputs.nur.overlay
          ];
        };
      in {
        nixosConfigurations = import ./systems { inherit inputs pkgs self; };
        homeConfigurations = import ./home { inherit inputs pkgs self; };
      };

    inputs = {
      # nixpkgs.
      nixpkgs.url = "github:NixOS/nixpkgs";

  		# hardware (for framework 13 - AMD 7040)
  		nixos-hardware.url = "github:NixOS/nixos-hardware/master";

  		# home-manager for easier user config.
  		home-manager = {
  			url = "github:nix-community/home-manager";
  			inputs.nixpkgs.follows = "nixpkgs";
  		};

  		# impermanence (I only keep /nix on reboot. Any persisting documents are stored in /nix/persist.)
  		impermanence = {
  			url = "github:nix-community/impermanence";
  		};

      # nur
      nur = {
        url = "github:nix-community/NUR";
      };
    };    
  }
#+end_src

* NixOS Configuration
** Bridge 

The following is the bridge file between the flake and the host configurations. This file returns the NixOS system for each host. Currently there is only one host:

- *valhalla*: Host for my Framework 13 AMD laptop.

#+begin_src nix :tangle ./systems/default.nix
  { inputs, pkgs, ...}:

  with inputs; 

  let 
  	inherit (nixpkgs.lib) nixosSystem;
  	inherit (pkgs) lib;	

  	valhallaModules = [
  		./valhalla 
  		impermanence.nixosModules.impermanence
  	];
  in {
  	valhalla = nixosSystem {
  		inherit pkgs;
  		specialArgs = { inherit inputs; };
  		modules = valhallaModules;
  	};
  }
#+end_src

** Services
*** Info
Describes different services for the NixOS system. Only add services here if they rely directly on the NixOS system and nixpkgs.

*** SSH

#+begin_src nix :tangle ./systems/services/ssh.nix
  { lib, pkgs, ... }: {
  	services.openssh = {
  		enable = true;
  		settings = {
  			PasswordAuthentication = false;
  			KbdInteractiveAuthentication = false;
  		};
  	};
  }
#+end_src

*** LXD

Currently this LXD configuration does not work and is not used.

#+begin_src nix :tangle ./systems/services/lxd.nix
  { lib, pkgs, ... }: {
    # https://srid.ca/lxc-nixos
    virtualisation.lxd.enable = true;

    virtualisation.lxd.preseed ={
      networks = [
        {
          name = "lxdbr0";
          type = "bridge";
          config = {
            "ipv4.address" = "10.0.100.1/24";
            "ipv4.nat" = "true";
          };
        }
      ];
      profiles = [
        {
          name = "default";
          devices = {
            eth0 = {
              name = "eth0";
              network = "lxdbr0";
              type = "nic";
            };
            root = {
              path = "/";
              pool = "default";
              size = "35GiB";
              type = "disk";
            };
          };
        }
      ];
      storage_pools = [
        {
          name = "default";
          driver = "dir";
          config = {
            source = "/var/lib/lxd/storage-pools/default";
          };
        }
      ];
    }; 
    /*virtualisation.lxc.systemConfig = ''
          security.nesting = true
          lxc.network.type = veth
          lxc.network.link = br0
          lxc.network.flags = up
      '';*/
  }
#+end_src

** Valhalla
*** Info

My main host. Currently configured for the Framework 13 laptop with an AMD processor.

*** Default

During <<installation>>, change the PARTUUID and UUID values below.

#+begin_src nix :tangle ./systems/valhalla/default.nix
  { config, inputs, lib, pkgs, ... }: {
  	imports = [
  		./hardware-configuration.nix
  		./configuration.nix
  		../services/ssh.nix
  	];

  	# DO NOT EDIT THESE UNLESS YOU ARE INSTALLING NIXOS!
  	# See installation guide in README on how to derive the UUIDs.
  	valhalla.hardware = {
  		enabled = true;
  		encryptedPARTUUID = "d2ce0233-c9d7-406a-9847-107ad0f0e3f7";
  		headerPARTUUID = "ab616024-7d8c-44e5-84da-e363e20781a6";
  		bootUUID = "5251-7E3F";
  		unencryptedUUID = "69ff994b-9f9d-4014-870f-964273c7944e";
  	};
  }
#+end_src
*** Configuration

Configuration analogous to the standard configuration generated during NixOS installation.

#+begin_src nix :tangle ./systems/valhalla/configuration.nix
  { inputs, lib, pkgs, ... }:

  let
  	persistDir = "/persist";
  in
  {
    imports = [
  	  inputs.nixos-hardware.nixosModules.framework-13-7040-amd
  	  ./persist.nix	
  	  ./pipewire.nix
  	  ./virt-manager.nix
    ];

    # Use the systemd-boot EFI boot loader.
    boot.loader.systemd-boot.enable = true;
    boot.loader.efi.canTouchEfiVariables = true;

    networking.hostName = "valhalla"; # Define your hostname.
    networking.networkmanager.enable = true;  # Easiest to use and most distros use this by default.

    # Set your time zone.
    services.automatic-timezoned.enable = true;

    # enable persistence
    valhalla.persist = {
  	  enable = true;
  	  inherit persistDir;
    };

    # hyprland is the GUI of choice
    programs.hyprland.enable = true;

    # hyprland requires /tmp/hypr to start, so create this
    systemd.tmpfiles.rules = [
  	  "d /tmp/hypr 0755 jalen users -" # cleanup is done on reboot through root wipe.
    ];

    # users
    users.mutableUsers = false;
    users.users.root.hashedPasswordFile = "${persistDir}/psk/root";
    users.users.jalen = {
  	  isNormalUser = true;
   	  home = "/home/jalen";
  	  extraGroups = [ "wheel" "networkmanager" ];
   	  hashedPasswordFile = "${persistDir}/psk/jalen";
  	  # packages = with pkgs; [ git vim wget ];
    };

    # Enable sound.
    sound.enable = true;
    hardware.pulseaudio.enable = true;

    # List packages installed in system profile. To search, run:
    # $ nix search wget
    environment.systemPackages = with pkgs; [ vim wget git ];

    system.stateVersion = "23.11"; # Did you read the comment?
    nix.settings.experimental-features = "nix-command flakes";
  }
#+end_src

*** Hardware

My configuration for the Framework 13 laptop. Do not edit directly. Refer to [[installation]] for changing PARTUUIDs and UUIDS. 

#+begin_src nix :tangle ./systems/valhalla/hardware-configuration.nix
  { config, lib, pkgs, modulesPath, ... }:

  with lib;
  let
  	cfg = config.valhalla.hardware;
  in
  {
  	imports = [
  		(modulesPath + "/installer/scan/not-detected.nix")
  	];

    options.valhalla.hardware = {
  		enabled = mkOption { type = types.bool; };
  		encryptedPARTUUID = mkOption { type = types.str; };
  		unencryptedUUID = mkOption { type = types.str; }; # 534cebad-1be2-4bdb-982d-835da3f6240a
  		bootUUID = mkOption { type = types.str; };
  		headerPARTUUID = mkOption { type = types.str; };
    };

  	config = mkIf cfg.enabled { 
  		boot.initrd.availableKernelModules = [ "nvme" "xhci_pci" "thunderbolt" "usb_storage" "sd_mod" ];
  		boot.initrd.kernelModules = [ ];
  		boot.kernelModules = [ "kvm-amd" ];
  		boot.extraModulePackages = [ ];

  		fileSystems."/" =
  		  { device = "/dev/disk/by-uuid/${cfg.unencryptedUUID}";
  		    fsType = "btrfs";
  		    options = [ "subvol=root" ];
  		  };

  		# luks boot info
  		boot.initrd.luks.devices = {
  			crypted = {
  				device = "/dev/disk/by-partuuid/${cfg.encryptedPARTUUID}"; # 9c41d5e1-8b1f-42cb-8bdc-8edd51973791
  				header = "/dev/disk/by-partuuid/${cfg.headerPARTUUID}"; # 23a9e2b8-d901-411a-a5f9-ea893072a5f4 
  				allowDiscards = true;
  				preLVM = true;
  			};
  		};

  		fileSystems."/persist" =
  		  { device = "/dev/disk/by-uuid/${cfg.unencryptedUUID}";
  		    fsType = "btrfs";
  		    neededForBoot = true;
  		    options = [ "subvol=persist" ];
  		  };

  		fileSystems."/nix" =
  		  { device = "/dev/disk/by-uuid/${cfg.unencryptedUUID}";
  		    fsType = "btrfs";
  		    options = [ "subvol=nix" ];
  		  };

  		fileSystems."/boot" =
  		  { device = "/dev/disk/by-uuid/${cfg.bootUUID}";
  		    fsType = "vfat";
  		  };

  		swapDevices = [ ];

  		boot.initrd.postDeviceCommands = lib.mkAfter ''
  			mkdir /btrfs_tmp
  			mount /dev/disk/by-uuid/${cfg.unencryptedUUID} /btrfs_tmp
  			if [[ -e /btrfs_tmp/root ]]; then
  				mkdir -p /btrfs_tmp/backups
  				timestamp=$(date --date="@$(stat -c %Y /btrfs_tmp/root)" "+%Y-%m-%-d_%H:%M:%S")
  				mv /btrfs_tmp/root "/btrfs_tmp/backups/$timestamp"
  			fi

  			delete_subvolume_recursively() {
  				IFS=$'\n'
  				for i in $(btrfs subvolume list -o "$1" | cut -f 9- -d ' '); do
  					delete_subvolume_recursively "/btrfs_tmp/$i"
  				done
  				btrfs subvolume delete "$1"
  			}

  			for i in $(find /btrfs_tmp/backups/ -maxdepth 1 -mtime +30); do
  				delete_subvolume_recursively "$i"
  			done

  			btrfs subvolume create /btrfs_tmp/root
  			umount /btrfs_tmp
  		'';

  		networking.useDHCP = lib.mkDefault true;
  		nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  		hardware.cpu.amd.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
  	};
  }
#+end_src
*** Impermanence

#+begin_src nix :tangle ./systems/valhalla/persist.nix
  { config, lib, pkgs, ... }:

  with lib;

  let
  	cfg = config.valhalla.persist;
  in
  {
  	options.valhalla.persist = {
  		enable = mkOption {
  			type = types.bool;
  			default = false;
  			description = ''
  				Signal whether to persist files and directories on reboot.
  			'';
  		};
  		persistDir = mkOption {
  			type = types.str;
  			default = "/nix/persist";
  			description = ''
  				String path for defining the persisting directory. All other persisting directories and files are stored here.
  			'';
  		};
  	};

  	config = mkIf cfg.enable {
  		# persist
  		environment.persistence."${cfg.persistDir}" = {
  			hideMounts = true;
  			directories = [
  				"/var/log"
  				"/var/lib/bluetooth"
  				"/var/lib/nixos"
  				"/var/lib/systemd/coredump"
  				"/etc/ssh"
  				"/etc/NetworkManager"
  				"/etc/nixos"
  			];
  			files = [
  				"/etc/nix/id_rsa"
  				"/etc/machine-id"
  				"/etc/systemd/resolved.conf" # using nextdns
  			];
  			users.jalen = {
  				directories = [
  					"Documents"
  					".local/state/nix/profiles"
  					".ssh"
  					".gnupg"
  					"Pictures"
  					"Music"
  					"VMs"
  					".emacs.d" # I don't want to sit forever while emacs installs everything.
  					# TODO create an emacs package manifest
  				];
  			};
  		};
  	};
  }
#+end_src

*** TLP

#+begin_src nix :tangle ./systems/valhalla/tlp.nix
  { lib, pkgs, ... }: {
  	services.tlp = {
  		enable = true;
  	};
  }
#+end_src

*** Pipewire

For microphones.

#+begin_src nix :tangle ./systems/valhalla/pipewire.nix 
  { config, lib, pkgs, ... }: {
  	security.rtkit.enable = true;
  	services.pipewire = {
  		pulse.enable = true;
  	};
  }
#+end_src

*** Virt Manager

#+begin_src nix :tangle ./systems/valhalla/virt-manager.nix
  { config, lib, pkgs, ... }: {
  	virtualisation.libvirtd.enable = true;
  	programs.virt-manager.enable = true;
  }
#+end_src
* TODO Home Configuration
** Info

This is where the bulk of the configuration lives.

** Bridge

Bridge from the ~nix flake~ to each individual user ~home-manager~ configuration.

#+begin_src nix :tangle ./home/default.nix
  { self, inputs, pkgs, ... }: 

  let
  	sharedModules = [
  		inputs.impermanence.nixosModules.home-manager.impermanence
  	];

  	homeImports = {
  		jalen = [ ./user.nix ] ++ sharedModules;
  	};

  	inherit (inputs.home-manager.lib) homeManagerConfiguration;
  in {
  	jalen = homeManagerConfiguration {
  		inherit pkgs;
  		extraSpecialArgs = { inherit inputs self; };
  		modules = homeImports.jalen;
  	}; 
  }
#+end_src

** Users
*** Jalen

#+begin_src nix :tangle ./home/user.nix
  { config, inputs, pkgs, ...}: 

  let
  	username = "jalen";
  	uniqueScripts = (import ./scripts) { inherit config pkgs; };

  	packages = with pkgs; [
  		# my scripts
  		uniqueScripts

  		# misc
  		# gobble
  		neofetch
  		pinentry
  		pinentry-curses
  		openssh
  		brightnessctl
  		acpi
  		gimp
  		libnotify
  		mpc-cli
  		ripgrep
  		discord
  		glow
  		zathura
      imagemagick

  		# math stuff
  		# mathematica # /nix/store/d692a31x9p74vxrnwdlqh5k5a7m4kqkd-Mathematica_13.3.1_BNDL_LINUX.sh

  		# notes and markup
  		logseq
  		zotero

  		# screenshot double wammy ;)
  		slurp
  		grim

  		# botware
      spotify
  		zoom-us

  		# TODO add fonts to fonts.fonts
  		victor-mono
  		font-awesome

  		# pulseaudio mixer.
  		pamixer
  	];

  in

  {
  	# fuck these .. are ugly
    imports = [
  		# Import theme (accessed via config.valhalla.theme)
  		../themes/oxocarbon/dark.nix

  		# GUI 
  		./wayland/hyprland
  		./wayland/waybar.nix

  		# Apps
  		./applications/ranger.nix
  		./applications/firefox 
  		./applications/tmux.nix
  		./applications/kitty
  		./applications/ncmpcpp.nix
  		./applications/emacs

  		# Editors
  		./applications/nvim

  		# Other
  		./utilities/mako.nix # notification daemon
    ];

    home = {
      inherit username;
      inherit packages;
      homeDirectory = "/home/${username}";
      stateVersion = "23.11";
    };

    dconf.settings = { # add to home-manager
      "org/virt-manager/virt-manager/connections" = {
        autoconnect = [ "qemu:///system" ];
        uris = [ "qemu:///system" ];
      };
    };

    programs = {
  		bash = {
  			enable = true;
  			bashrcExtra = ''
          #    if command -v tmux &> /dev/null && [ -n "$PS1" ] && [[ ! "$TERM" =~ screen ]] && [[ ! "$TERM" =~ tmux ]] && [ -z "$TMUX" ]; then
          #    exec tmux attach
          #    fi
  			'';
  		};
  		ssh.enable = true;
  		git = {
  			enable = true;
  			package = pkgs.gitAndTools.gitFull;
  			userName = "mjalen"; 
  			userEmail = "ajalenboi@gmail.com"; # email me [ at your own peril >:) ]
  			extraConfig = {
  				color.ui = "always";
  			};
  		};
  	};
  }
#+end_src

** Applications
*** Emacs 

Truly a long configuration just to act as a bootloader ;)

#+begin_src nix :tangle ./home/applications/emacs/default.nix
  { config, pkgs, ... }:

  let
  	hm = config.home.homeDirectory;
  in
  {
  	services.emacs = {
  		enable = true;
  		defaultEditor = true;
  		package = pkgs.emacs29-pgtk;
  	};

  	programs.emacs = {
  		enable = true;
  		package = pkgs.emacs29-pgtk;
  	};

    home.packages = with pkgs; [ cmake texliveFull ]; # may be good to add this to user instead perhaps?

  	systemd.user.tmpfiles.rules = [
  		# "d ${hm}/.emacs.d 0755 jalen users - -" # Create emacs directory.
  		# link config files.
  		"L+ ${hm}/.emacs.d/config.org - - - - ${hm}/Documents/dot/home/applications/emacs/emacs.d/config.org"
  		"L+ ${hm}/.emacs.d/init.el - - - - ${hm}/Documents/dot/home/applications/emacs/emacs.d/init.el"
  	];
  }

#+end_src

*** Firefox
**** Default

- <<userChrome injection>> The ~userChrome.css~ depends on this nix file. 

#+begin_src nix :tangle ./home/applications/firefox/default.nix
  { config, pkgs, ... }: 

  with config.valhalla.theme;
  {
    # firefox stuffs
    programs.firefox = {
      enable = true;
      profiles = {
        default = {
          isDefault = true;
          extensions = with pkgs.nur.repos.rycee.firefox-addons; [
            ublock-origin
            sponsorblock
            old-reddit-redirect
  		      darkreader
          ];
          settings = {
            "identity.fxaccounts.enabled" = false;
            "extensions.pocket.enabled" = false;
            "extensions.autoDisableScopes" = 0;
            "toolkit.legacyUserProfileCustomizations.stylesheets" = true;
  					"extensions.activeThemeID" = "firefox-compact-dark@mozilla.org";
            "extensions.getAddons.cache.enabled" = false;
  					"media.rdd-ffmpeg.enabled" = true;
  					"media.ffmpeg.vaapi.enabled" = true;
  					"media.navigator.mediadatadecoder_vpx_enabled" = true;
  					"gfx.webrender.all" = true;

  					"browser.startup.blankWindow" = true;
  					"browser.sessionstore.resume_session_once" = true;

  					# Why would I want this?
  					"toolkit.telemetry.archive.enabled" = false;
  					"toolkit.telemetry.enabled" = false;
  					"toolkit.telemetry.rejected" = true;
  					"toolkit.telemetry.server" = "<clear value>";
  					"toolkit.telemetry.unified" = false;
  					"toolkit.telemetry.unifiedIsOptIn" = false;
          };
          userChrome = builtins.readFile ./userChrome.css;
        };
      };
    };
  }
#+end_src

**** User Chrome

*WARNING*  This is not a *complete* ~userChrome.css~ file. It depends on custom nix theme variables that are inserted here: [[userChrome injection]].

#+begin_src css :tangle ./home/applications/firefox/userChrome.css
  @namespace url("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");

  #TabsToolbar .titlebar-spacer[type="post-tabs"] {
  	display: none !important;
  }

  #TabsToolbar > .titlebar-buttonbox-container {
      display: none !important;
  }

  /* The following is stolen from github:MrOtherGuy/firefox-csshacks - tabs_on_bottom.css */
  #titlebar {
  	order: 2;
  	-moz-appearance: none !important;
  	--tabs-navbar-shadow-size: 0px;
  	--uc-menubar-vertical-overlap: 19px;
  }

  #navigator-toolbox > div { display: contents }

  .global-notificationbox,
  #tab-notification-deck {
  	order: 2;
  }

  #TabsToolbar .titlebar-spacer{ display: none; }
  /* Also hide the toolbox bottom border which isn't at bottom with this setup */
  #navigator-toolbox::after{ display: none !important; }

  @media (-moz-gtk-csd-close-button){
    .titlebar-button{
      flex-direction: column;
    }
  }

  /* At Activated Menubar */
  :root:not([chromehidden~="menubar"], [sizemode="fullscreen"]) #toolbar-menubar:not([autohide="true"]) + #TabsToolbar > .titlebar-buttonbox-container {
    display: block !important;
  }
  #toolbar-menubar:not([autohide="true"]) > .titlebar-buttonbox-container {
    visibility: hidden;
  }

  /* These exist only for compatibility with autohide-tabstoolbar.css */
  toolbox#navigator-toolbox > toolbar#nav-bar.browser-toolbar{ animation: none; }
  #navigator-toolbox:hover #TabsToolbar{ animation: slidein ease-out 48ms 1 }
  #TabsToolbar > .titlebar-buttonbox-container{ visibility: visible }
  #navigator-toolbox:not(:-moz-lwtheme){ background-color: -moz-dialog }

  window, #toolbar-menubar, #TabsToolbar, #PersonalToolbar, #navigator-toolbox,#sidebar-box, .titlebar-spacer,
  #nav-bar, .tab-background[selected="true"], {
  	background-color: rgba(${blackAsDec}, 0.4) !important;
  	-moz-appearance: none !important;
  	background-image: none !important;
  }
#+end_src
