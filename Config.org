#+PROPERTY: header-args+ :comments both
#+PROPERTY: header-args+ :mkdirp yes
#+PROPERTY: header-args+ :tangle "<filename>"
#+title: Nix Configuration
#+author: Jalen Moore

* Flake

The flake file for the entire configuration.

#+begin_src nix :tangle ./flake.nix
  { 
    description = ''Jalen Moore's Nix configuration.'';

    outputs = { self, ... } @ inputs:
      let
        system = "x86_64-linux";
        pkgs = import inputs.nixpkgs {
          inherit system;
          config.allowUnfree = true;
          overlays = [ 
            inputs.nur.overlay
          ];
        };
      in {
        nixosConfigurations = import ./systems { inherit inputs pkgs self; };
        homeConfigurations = import ./home { inherit inputs pkgs self; };
      };

    inputs = {
      # nixpkgs.
      nixpkgs.url = "github:NixOS/nixpkgs";

  		# hardware (for framework 13 - AMD 7040)
  		nixos-hardware.url = "github:NixOS/nixos-hardware/master";

  		# home-manager for easier user config.
  		home-manager = {
  			url = "github:nix-community/home-manager";
  			inputs.nixpkgs.follows = "nixpkgs";
  		};

  		# impermanence (I only keep /nix on reboot. Any persisting documents are stored in /nix/persist.)
  		impermanence = {
  			url = "github:nix-community/impermanence";
  		};

      # nur
      nur = {
        url = "github:nix-community/NUR";
      };
    };    
  }
#+end_src

* NixOS Configuration
** Gateway

This file acts as a gateway between our flake and the host configurations.

#+begin_src nix :tangle ./systems/default.nix
  { inputs, pkgs, ...}:

  with inputs; 

  let 
  	inherit (nixpkgs.lib) nixosSystem;
  	inherit (pkgs) lib;	

  	valhallaModules = [
  		./valhalla 
  		impermanence.nixosModules.impermanence
  	];
  in {
  	valhalla = nixosSystem {
  		inherit pkgs;
  		specialArgs = { inherit inputs; };
  		modules = valhallaModules;
  	};
  }
#+end_src

** Services
*** SSH

#+begin_src nix :tangle ./systems/services/ssh.nix
  { lib, pkgs, ... }: {
  	services.openssh = {
  		enable = true;
  		settings = {
  			PasswordAuthentication = false;
  			KbdInteractiveAuthentication = false;
  		};
  	};
  }
#+end_src

*** LXD

Currently this LXD configuration does not work.

#+begin_src nix :tangle ./systems/services/lxd.nix
  { lib, pkgs, ... }: {
    # https://srid.ca/lxc-nixos
    virtualisation.lxd.enable = true;

    virtualisation.lxd.preseed ={
      networks = [
        {
          name = "lxdbr0";
          type = "bridge";
          config = {
            "ipv4.address" = "10.0.100.1/24";
            "ipv4.nat" = "true";
          };
        }
      ];
      profiles = [
        {
          name = "default";
          devices = {
            eth0 = {
              name = "eth0";
              network = "lxdbr0";
              type = "nic";
            };
            root = {
              path = "/";
              pool = "default";
              size = "35GiB";
              type = "disk";
            };
          };
        }
      ];
      storage_pools = [
        {
          name = "default";
          driver = "dir";
          config = {
            source = "/var/lib/lxd/storage-pools/default";
          };
        }
      ];
    }; 
    /*virtualisation.lxc.systemConfig = ''
          security.nesting = true
          lxc.network.type = veth
          lxc.network.link = br0
          lxc.network.flags = up
      '';*/
  }
#+end_src

** Valhalla

My main host. Currently configured for the Framework 13 laptop with an AMD processor.

*** Default

During <<installation>>, change the PARTUUID and UUID values below.

#+begin_src nix :tangle ./systems/valhalla/default.nix
  { config, inputs, lib, pkgs, ... }: {
  	imports = [
  		./hardware-configuration.nix
  		./configuration.nix
  		../services/ssh.nix
  	];

  	# DO NOT EDIT THESE UNLESS YOU ARE INSTALLING NIXOS!
  	# See installation guide in README on how to derive the UUIDs.
  	valhalla.hardware = {
  		enabled = true;
  		encryptedPARTUUID = "d2ce0233-c9d7-406a-9847-107ad0f0e3f7";
  		headerPARTUUID = "ab616024-7d8c-44e5-84da-e363e20781a6";
  		bootUUID = "5251-7E3F";
  		unencryptedUUID = "69ff994b-9f9d-4014-870f-964273c7944e";
  	};
  }
#+end_src
*** Configuration

Configuration analogous to the standard configuration generated during NixOS installation.

#+begin_src nix :tangle ./systems/valhalla/configuration.nix
  { inputs, lib, pkgs, ... }:

  let
  	persistDir = "/persist";
  in
  {
    imports = [
  	  inputs.nixos-hardware.nixosModules.framework-13-7040-amd
  	  ./persist.nix	
  	  ./pipewire.nix
  	  ./virt-manager.nix
    ];

    # Use the systemd-boot EFI boot loader.
    boot.loader.systemd-boot.enable = true;
    boot.loader.efi.canTouchEfiVariables = true;

    networking.hostName = "valhalla"; # Define your hostname.
    networking.networkmanager.enable = true;  # Easiest to use and most distros use this by default.

    # Set your time zone.
    services.automatic-timezoned.enable = true;

    # enable persistence
    valhalla.persist = {
  	  enable = true;
  	  inherit persistDir;
    };

    # hyprland is the GUI of choice
    programs.hyprland.enable = true;

    # hyprland requires /tmp/hypr to start, so create this
    systemd.tmpfiles.rules = [
  	  "d /tmp/hypr 0755 jalen users -" # cleanup is done on reboot through root wipe.
    ];

    # users
    users.mutableUsers = false;
    users.users.root.hashedPasswordFile = "${persistDir}/psk/root";
    users.users.jalen = {
  	  isNormalUser = true;
   	  home = "/home/jalen";
  	  extraGroups = [ "wheel" "networkmanager" ];
   	  hashedPasswordFile = "${persistDir}/psk/jalen";
  	  # packages = with pkgs; [ git vim wget ];
    };

    # Enable sound.
    sound.enable = true;
    hardware.pulseaudio.enable = true;

    # List packages installed in system profile. To search, run:
    # $ nix search wget
    environment.systemPackages = with pkgs; [ vim wget git ];

    system.stateVersion = "23.11"; # Did you read the comment?
    nix.settings.experimental-features = "nix-command flakes";
  }
#+end_src

*** Hardware

My configuration for the Framework 13 laptop. Do not edit directly. Refer to [[installation]] for changing PARTUUIDs and UUIDS. 

#+begin_src nix :tangle ./systems/valhalla/hardware-configuration.nix
  { config, lib, pkgs, modulesPath, ... }:

  with lib;
  let
  	cfg = config.valhalla.hardware;
  in
  {
  	imports = [
  		(modulesPath + "/installer/scan/not-detected.nix")
  	];

    options.valhalla.hardware = {
  		enabled = mkOption { type = types.bool; };
  		encryptedPARTUUID = mkOption { type = types.str; };
  		unencryptedUUID = mkOption { type = types.str; }; # 534cebad-1be2-4bdb-982d-835da3f6240a
  		bootUUID = mkOption { type = types.str; };
  		headerPARTUUID = mkOption { type = types.str; };
    };

  	config = mkIf cfg.enabled { 
  		boot.initrd.availableKernelModules = [ "nvme" "xhci_pci" "thunderbolt" "usb_storage" "sd_mod" ];
  		boot.initrd.kernelModules = [ ];
  		boot.kernelModules = [ "kvm-amd" ];
  		boot.extraModulePackages = [ ];

  		fileSystems."/" =
  		  { device = "/dev/disk/by-uuid/${cfg.unencryptedUUID}";
  		    fsType = "btrfs";
  		    options = [ "subvol=root" ];
  		  };

  		# luks boot info
  		boot.initrd.luks.devices = {
  			crypted = {
  				device = "/dev/disk/by-partuuid/${cfg.encryptedPARTUUID}"; # 9c41d5e1-8b1f-42cb-8bdc-8edd51973791
  				header = "/dev/disk/by-partuuid/${cfg.headerPARTUUID}"; # 23a9e2b8-d901-411a-a5f9-ea893072a5f4 
  				allowDiscards = true;
  				preLVM = true;
  			};
  		};

  		fileSystems."/persist" =
  		  { device = "/dev/disk/by-uuid/${cfg.unencryptedUUID}";
  		    fsType = "btrfs";
  		    neededForBoot = true;
  		    options = [ "subvol=persist" ];
  		  };

  		fileSystems."/nix" =
  		  { device = "/dev/disk/by-uuid/${cfg.unencryptedUUID}";
  		    fsType = "btrfs";
  		    options = [ "subvol=nix" ];
  		  };

  		fileSystems."/boot" =
  		  { device = "/dev/disk/by-uuid/${cfg.bootUUID}";
  		    fsType = "vfat";
  		  };

  		swapDevices = [ ];

  		boot.initrd.postDeviceCommands = lib.mkAfter ''
  			mkdir /btrfs_tmp
  			mount /dev/disk/by-uuid/${cfg.unencryptedUUID} /btrfs_tmp
  			if [[ -e /btrfs_tmp/root ]]; then
  				mkdir -p /btrfs_tmp/backups
  				timestamp=$(date --date="@$(stat -c %Y /btrfs_tmp/root)" "+%Y-%m-%-d_%H:%M:%S")
  				mv /btrfs_tmp/root "/btrfs_tmp/backups/$timestamp"
  			fi

  			delete_subvolume_recursively() {
  				IFS=$'\n'
  				for i in $(btrfs subvolume list -o "$1" | cut -f 9- -d ' '); do
  					delete_subvolume_recursively "/btrfs_tmp/$i"
  				done
  				btrfs subvolume delete "$1"
  			}

  			for i in $(find /btrfs_tmp/backups/ -maxdepth 1 -mtime +30); do
  				delete_subvolume_recursively "$i"
  			done

  			btrfs subvolume create /btrfs_tmp/root
  			umount /btrfs_tmp
  		'';

  		networking.useDHCP = lib.mkDefault true;
  		nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  		hardware.cpu.amd.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
  	};
  }
#+end_src
*** Impermanence

#+begin_src nix :tangle ./systems/valhalla/persist.nix
  { config, lib, pkgs, ... }:

  with lib;

  let
  	cfg = config.valhalla.persist;
  in
  {
  	options.valhalla.persist = {
  		enable = mkOption {
  			type = types.bool;
  			default = false;
  			description = ''
  				Signal whether to persist files and directories on reboot.
  			'';
  		};
  		persistDir = mkOption {
  			type = types.str;
  			default = "/nix/persist";
  			description = ''
  				String path for defining the persisting directory. All other persisting directories and files are stored here.
  			'';
  		};
  	};

  	config = mkIf cfg.enable {
  		# persist
  		environment.persistence."${cfg.persistDir}" = {
  			hideMounts = true;
  			directories = [
  				"/var/log"
  				"/var/lib/bluetooth"
  				"/var/lib/nixos"
  				"/var/lib/systemd/coredump"
  				"/etc/ssh"
  				"/etc/NetworkManager"
  				"/etc/nixos"
  			];
  			files = [
  				"/etc/nix/id_rsa"
  				"/etc/machine-id"
  				"/etc/systemd/resolved.conf" # using nextdns
  			];
  			users.jalen = {
  				directories = [
  					"Documents"
  					".local/state/nix/profiles"
  					".ssh"
  					".gnupg"
  					"Pictures"
  					"Music"
  					"VMs"
  					".emacs.d" # I don't want to sit forever while emacs installs everything.
  					# TODO create an emacs package manifest
  				];
  			};
  		};
  	};
  }
#+end_src

*** TLP

#+begin_src nix :tangle ./systems/valhalla/tlp.nix
  { lib, pkgs, ... }: {
  	services.tlp = {
  		enable = true;
  	};
  }
#+end_src

*** Pipewire

For microphones.

#+begin_src nix :tangle ./systems/valhalla/pipewire.nix 
  { config, lib, pkgs, ... }: {
  	security.rtkit.enable = true;
  	services.pipewire = {
  		pulse.enable = true;
  	};
  }
#+end_src

*** Virt Manager

#+begin_src nix :tangle ./systems/valhalla/virt-manager.nix
  { config, lib, pkgs, ... }: {
  	virtualisation.libvirtd.enable = true;
  	programs.virt-manager.enable = true;
  }
#+end_src
* TODO Home Configuration

This is where the bulk of the configuration lives.
